import { PongTournamentScoresABI, PongTournamentScoresBytecode } from './contractConfig';
import { keccak256 } from 'js-sha3';

export class BlockchainService {
    private contractAddress: string | null = null;
    private connectedAddress: string | null = null;
    private scoreUpdateCallbacks: ((player: string, score: number) => void)[] = [];
    private updateInterval: NodeJS.Timeout | null = null;

    constructor() {
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑ localStorage
        this.contractAddress = localStorage.getItem('blockchainContractAddress');
        this.connectedAddress = localStorage.getItem('blockchainConnectedAddress');
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ Core.app
    private isCoreAppAvailable(): boolean {
        return typeof window !== 'undefined' &&
            typeof window.avalanche !== 'undefined' &&
            window.avalanche !== null;
    }

    // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–æ—à–µ–ª—å–∫—É Core.app
    public async connectWallet(): Promise<string | null> {
        if (!this.isCoreAppAvailable() || !window.avalanche) {
            throw new Error('Core.app —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ');
        }

        try {
            // –ó–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–æ—à–µ–ª—å–∫—É
            const accounts = await window.avalanche.request({ method: 'eth_requestAccounts' });
            if (accounts && accounts.length > 0) {
                this.connectedAddress = accounts[0];
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –º–µ–∂–¥—É —ç–∫–∑–µ–º–ø–ª—è—Ä–∞–º–∏
                localStorage.setItem('blockchainConnectedAddress', accounts[0]);
                return this.connectedAddress;
            }
            return null;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∫–æ—à–µ–ª—å–∫—É:', error);
            throw error;
        }
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω–æ–≥–æ –∞–¥—Ä–µ—Å–∞
    public getConnectedAddress(): string | null {
        // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        if (this.connectedAddress) {
            return this.connectedAddress;
        }
        // –ï—Å–ª–∏ –Ω–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º localStorage
        const saved = localStorage.getItem('blockchainConnectedAddress');
        if (saved) {
            this.connectedAddress = saved;
            return saved;
        }
        return null;
    }

    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞–¥—Ä–µ—Å–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
    public setContractAddress(address: string): void {
        this.contractAddress = address;
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –º–µ–∂–¥—É —ç–∫–∑–µ–º–ø–ª—è—Ä–∞–º–∏
        localStorage.setItem('blockchainContractAddress', address);
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
    public getContractAddress(): string | null {
        // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        if (this.contractAddress) {
            return this.contractAddress;
        }
        // –ï—Å–ª–∏ –Ω–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º localStorage
        const saved = localStorage.getItem('blockchainContractAddress');
        if (saved) {
            this.contractAddress = saved;
            return saved;
        }
        return null;
    }

    // –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
    public async deployContract(): Promise<string | null> {
        if (!this.connectedAddress) {
            throw new Error('–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª–µ–∫');
        }

        if (!this.isCoreAppAvailable() || !window.avalanche) {
            throw new Error('Core.app —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ');
        }

        try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –±–∞–π—Ç–∫–æ–¥–∞
            if (!PongTournamentScoresBytecode || !PongTournamentScoresBytecode.startsWith('0x')) {
                throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –±–∞–π—Ç–∫–æ–¥ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞');
            }

            console.log('–†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏:', {
                from: this.connectedAddress,
                dataLength: PongTournamentScoresBytecode.length
            });

            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä–∏–º –±–∞–ª–∞–Ω—Å
            const balance = await window.avalanche.request({
                method: 'eth_getBalance',
                params: [this.connectedAddress, 'latest']
            });

            console.log('–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:', balance);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è
            const balanceWei = parseInt(balance, 16);
            const gasLimit = parseInt('0x3D0900', 16); // 4000000 - —É–≤–µ–ª–∏—á–∏–ª–∏ –ª–∏–º–∏—Ç –¥–ª—è –±–æ–ª—å—à–∏—Ö –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
            const gasPrice = parseInt('0x3B9ACA00', 16); // 1 gwei - —É–º–µ–Ω—å—à–∏–ª–∏ —Ü–µ–Ω—É –≥–∞–∑–∞
            const requiredWei = gasLimit * gasPrice;

            console.log('–ù–µ–æ–±—Ö–æ–¥–∏–º–æ Wei:', requiredWei, '–î–æ—Å—Ç—É–ø–Ω–æ Wei:', balanceWei);

            if (balanceWei < requiredWei) {
                throw new Error(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤. –ù–µ–æ–±—Ö–æ–¥–∏–º–æ: ${requiredWei / 1e18} AVAX, –¥–æ—Å—Ç—É–ø–Ω–æ: ${balanceWei / 1e18} AVAX`);
            }

            // –ü—Ä–æ–±—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è
            let txHash;

            try {
                // –í–∞—Ä–∏–∞–Ω—Ç 1: EIP-1559 –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è Avalanche
                console.log('–ü–æ–ø—ã—Ç–∫–∞ 1: EIP-1559 –ø–∞—Ä–∞–º–µ—Ç—Ä—ã');
                const minimalParams = {
                    from: this.connectedAddress,
                    data: PongTournamentScoresBytecode,
                    maxFeePerGas: '0x77359400', // 2 gwei –≤ hex
                    maxPriorityFeePerGas: '0x77359400', // 2 gwei –≤ hex
                    value: '0x0'
                };

                console.log('EIP-1559 –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:', minimalParams);

                txHash = await window.avalanche.request({
                    method: 'eth_sendTransaction',
                    params: [minimalParams]
                });
            } catch (minimalError) {
                console.log('EIP-1559 –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º —Å –ª–∏–º–∏—Ç–æ–º –≥–∞–∑–∞:', minimalError);

                try {
                    // –í–∞—Ä–∏–∞–Ω—Ç 2: –° –ª–∏–º–∏—Ç–æ–º –≥–∞–∑–∞ –∏ EIP-1559
                    console.log('–ü–æ–ø—ã—Ç–∫–∞ 2: –° –ª–∏–º–∏—Ç–æ–º –≥–∞–∑–∞ –∏ EIP-1559');
                    const gasParams = {
                        from: this.connectedAddress,
                        data: PongTournamentScoresBytecode,
                        gas: '0x7A120', // 500000 –≤ hex
                        maxFeePerGas: '0x77359400', // 2 gwei –≤ hex
                        maxPriorityFeePerGas: '0x77359400', // 2 gwei –≤ hex
                        value: '0x0'
                    };

                    console.log('–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å –ª–∏–º–∏—Ç–æ–º –≥–∞–∑–∞ –∏ EIP-1559:', gasParams);

                    txHash = await window.avalanche.request({
                        method: 'eth_sendTransaction',
                        params: [gasParams]
                    });
                } catch (gasError) {
                    console.log('–õ–∏–º–∏—Ç –≥–∞–∑–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º –≤—ã—Å–æ–∫–∏–π –ª–∏–º–∏—Ç:', gasError);

                    // –í–∞—Ä–∏–∞–Ω—Ç 3: Legacy gasPrice –∫–∞–∫ –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞
                    console.log('–ü–æ–ø—ã—Ç–∫–∞ 3: Legacy gasPrice');
                    const highGasParams = {
                        from: this.connectedAddress,
                        data: PongTournamentScoresBytecode,
                        gas: '0x989680', // 10000000 –≤ hex - –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π –ª–∏–º–∏—Ç
                        gasPrice: '0x77359400', // 2 gwei –≤ hex - legacy gas price
                        value: '0x0'
                    };

                    console.log('–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å legacy gasPrice:', highGasParams);

                    txHash = await window.avalanche.request({
                        method: 'eth_sendTransaction',
                        params: [highGasParams]
                    });
                }
            }

            console.log('–ü–æ–ª—É—á–µ–Ω —Ö–µ—à —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏:', txHash);

            // –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
            const receipt = await this.waitForTransaction(txHash);
            if (receipt && receipt.contractAddress) {
                this.setContractAddress(receipt.contractAddress); // –ò—Å–ø–æ–ª—å–∑—É–µ–º setContractAddress –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ localStorage
                return this.contractAddress;
            }
            return null;
        } catch (error: any) {
            console.error('–û—à–∏–±–∫–∞ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞:', error);

            // –î–µ—Ç–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –æ—à–∏–±–æ–∫
            if (error?.code === -32603) {
                throw new Error('–û—à–∏–±–∫–∞ RPC: –í–æ–∑–º–æ–∂–Ω–æ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –∏–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≥–∞–∑–∞');
            } else if (error?.code === 4001) {
                throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–∫–ª–æ–Ω–∏–ª —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é');
            } else if (error?.message?.includes('insufficient funds')) {
                throw new Error('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ —Å—á–µ—Ç—É –¥–ª—è —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞');
            } else if (error?.message?.includes('gas')) {
                throw new Error('–û—à–∏–±–∫–∞ —Å –≥–∞–∑–æ–º: –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —É–≤–µ–ª–∏—á–∏—Ç—å –ª–∏–º–∏—Ç –≥–∞–∑–∞');
            } else {
                throw new Error(`–û—à–∏–±–∫–∞ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è: ${error?.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`);
            }
        }
    }

    // –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    private async waitForTransaction(txHash: string): Promise<any> {
        if (!window.avalanche) {
            throw new Error('Core.app –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
        }

        return new Promise((resolve, reject) => {
            const checkReceipt = async () => {
                try {
                    if (!window.avalanche) {
                        reject(new Error('Core.app –ø–æ—Ç–µ—Ä—è–Ω –≤–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è'));
                        return;
                    }

                    const receipt = await window.avalanche.request({
                        method: 'eth_getTransactionReceipt',
                        params: [txHash]
                    });

                    if (receipt) {
                        resolve(receipt);
                    } else {
                        setTimeout(checkReceipt, 2000);
                    }
                } catch (error) {
                    reject(error);
                }
            };

            checkReceipt();
        });
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—á–µ—Ç–∞ –∏–≥—Ä–æ–∫–∞
    public async getPlayerScore(playerAddress: string): Promise<number> {
        if (!this.contractAddress) {
            throw new Error('–ê–¥—Ä–µ—Å –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
        }

        if (!window.avalanche) {
            throw new Error('Core.app –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
        }

        try {
            // –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏
            const data = this.encodeCall('getScore', ['address'], [playerAddress]);

            // –í—ã–∑–æ–≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
            const result = await window.avalanche.request({
                method: 'eth_call',
                params: [{
                    to: this.contractAddress,
                    data
                }, 'latest']
            });

            // –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            return parseInt(result, 16);
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—á–µ—Ç–∞ –∏–≥—Ä–æ–∫–∞:', error);
            throw error;
        }
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –∏–≥—Ä–æ–∫–∞
    public async getPlayerName(playerAddress: string): Promise<string> {
        if (!this.contractAddress) {
            throw new Error('–ê–¥—Ä–µ—Å –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
        }

        if (!window.avalanche) {
            throw new Error('Core.app –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
        }

        try {
            // –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏
            const data = this.encodeCall('getPlayerName', ['address'], [playerAddress]);

            // –í—ã–∑–æ–≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
            const result = await window.avalanche.request({
                method: 'eth_call',
                params: [{
                    to: this.contractAddress,
                    data
                }, 'latest']
            });

            console.log(`getPlayerName(${playerAddress}) raw result:`, result);

            // –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –∏–∑ hex
            if (!result || result === '0x' || result.length < 130) {
                console.log(`No valid name data for address ${playerAddress}`);
                return '';
            }

            try {
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—ã–µ 64 —Å–∏–º–≤–æ–ª–∞ (32 –±–∞–π—Ç–∞ offset) –∏ —Å–ª–µ–¥—É—é—â–∏–µ 64 —Å–∏–º–≤–æ–ª–∞ (32 –±–∞–π—Ç–∞ length)
                if (result.length < 130) {
                    return '';
                }

                const lengthHex = result.slice(66, 130); // –î–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏
                const length = parseInt(lengthHex, 16);

                if (length === 0) {
                    return '';
                }

                const hexString = result.slice(130, 130 + length * 2); // –î–∞–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏

                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º hex –≤ —Å—Ç—Ä–æ–∫—É
                let name = '';
                for (let i = 0; i < hexString.length; i += 2) {
                    const hex = hexString.substr(i, 2);
                    const charCode = parseInt(hex, 16);
                    if (charCode > 0) {
                        name += String.fromCharCode(charCode);
                    }
                }

                return name.trim();
            } catch (decodeError) {
                console.warn('Error decoding player name:', decodeError);
                return '';
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Error getting player name (using fallback):', error);
            return ''; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É –≤–º–µ—Å—Ç–æ –≤—ã–±—Ä–æ—Å–∞ –æ—à–∏–±–∫–∏
        }
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤ –∏ –∏—Ö —Å—á–µ—Ç–æ–≤ (—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å –Ω–æ–≤—ã–º –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–º)
    public async getAllPlayers(): Promise<Array<{ address: string, name: string, score: number }>> {
        if (!this.contractAddress) {
            console.warn('Contract address not set');
            return [];
        }

        if (!window.avalanche) {
            console.warn('Core.app not available');
            return [];
        }

        try {
            console.log(`üîç Checking players in new contract: ${this.contractAddress}`);

            // –ü—Ä–æ–≤–µ—Ä–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–≥—Ä–æ–∫–æ–≤
            const countData = this.encodeCall('getPlayersCount', [], []);
            const countResult = await window.avalanche.request({
                method: 'eth_call',
                params: [{
                    to: this.contractAddress,
                    data: countData
                }, 'latest']
            });

            const playerCount = parseInt(countResult, 16);
            console.log(`üìä Player count from new contract: ${playerCount}`);

            if (playerCount > 0) {
                // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ –æ–¥–Ω–æ–º—É –∏–≥—Ä–æ–∫—É
                const players = [];
                for (let i = 0; i < Math.min(playerCount, 10); i++) { // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º 10 –∏–≥—Ä–æ–∫–∞–º–∏
                    try {
                        // –ü–æ–ª—É—á–∞–µ–º –∞–¥—Ä–µ—Å –∏–≥—Ä–æ–∫–∞
                        const playerData = this.encodeCall('getPlayer', ['uint256'], [i.toString()]);
                        const playerResult = await window.avalanche.request({
                            method: 'eth_call',
                            params: [{
                                to: this.contractAddress,
                                data: playerData
                            }, 'latest']
                        });

                        if (playerResult && playerResult !== '0x') {
                            const playerAddress = '0x' + playerResult.slice(-40);
                            console.log(`Player ${i}: ${playerAddress}`);

                            // –ü–æ–ª—É—á–∞–µ–º –∏–º—è –∏ —Å—á–µ—Ç –∏–≥—Ä–æ–∫–∞
                            const name = await this.getPlayerName(playerAddress);
                            const score = await this.getPlayerScore(playerAddress);

                            players.push({
                                address: playerAddress,
                                name: name || `Player ${i + 1}`,
                                score: score
                            });
                        }
                    } catch (playerError) {
                        console.warn(`Error getting player ${i}:`, playerError);
                    }
                }

                console.log(`‚úÖ Found ${players.length} players in new contract`);
                return players;
            }

            // Fallback: –ø—Ä–æ–≤–µ—Ä–∏–º —Ç–µ–∫—É—â–∏–π –∫–æ—à–µ–ª–µ–∫
            if (this.connectedAddress) {
                try {
                    console.log('üîÑ Checking current wallet directly');
                    const myScore = await this.getPlayerScore(this.connectedAddress);
                    const myName = await this.getPlayerName(this.connectedAddress);
                    
                    if (myScore > 0) {
                        console.log('‚úÖ Found score for current wallet');
                        return [{
                            address: this.connectedAddress,
                            name: myName || 'Current Player',
                            score: myScore
                        }];
                    }
                } catch (altError) {
                    console.warn('Current wallet check failed:', altError);
                }
            }

            console.log('No players found');
            return [];
        } catch (error) {
            console.error('Error getting all players:', error);
            return [];
        }
    }
    }

    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—á–µ—Ç–∞ –∏–≥—Ä–æ–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞)
    public async setPlayerScore(playerAddress: string, playerName: string, score: number): Promise<void> {
        if (!window.avalanche) {
            throw new Error('Core.app –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
        }

        console.log('Adding score for player:', playerAddress, 'name:', playerName, 'score:', score);

        // –ö–æ–Ω—Ç—Ä–∞–∫—Ç —Ç–µ–ø–µ—Ä—å —Å–∞–º –Ω–∞–∫–∞–ø–ª–∏–≤–∞–µ—Ç –æ—á–∫–∏ (scores[player] += score)
        await this.setPlayerScoreWithName(playerAddress, playerName, score);
        console.log('‚úÖ Score added to blockchain:', playerName, `(${playerAddress}) += ${score} points`);
    }

    // –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∑–∞–ø–∏—Å–∏ –∏–≥—Ä—ã
    private async setPlayerScoreWithName(playerAddress: string, playerName: string, score: number): Promise<void> {
        if (!window.avalanche) {
            throw new Error('Core.app not available');
        }

        console.log('Recording game for player:', playerAddress, 'name:', playerName, 'score:', score);

        // –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–∑–æ–≤–∞ –Ω–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ recordGame
        const data = this.encodeCall('recordGame', ['address', 'string', 'uint256'], [playerAddress, playerName, score.toString()]);

        console.log('Transaction data:', data);

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ EIP-1559 –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        const txParams = {
            from: this.connectedAddress,
            to: this.contractAddress,
            data,
            gas: '0x61A80', // 400000 –≤ hex - —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π –ª–∏–º–∏—Ç –¥–ª—è —Å—Ç—Ä–æ–∫
            maxFeePerGas: '0x77359400', // 2 gwei –≤ hex - —É–≤–µ–ª–∏—á–∏–ª–∏ fee
            maxPriorityFeePerGas: '0x77359400', // 2 gwei –≤ hex - —É–≤–µ–ª–∏—á–∏–ª–∏ priority fee
            value: '0x0'
        };

        console.log('Transaction params:', txParams);

        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        const txHash = await window.avalanche.request({
            method: 'eth_sendTransaction',
            params: [txParams]
        });

        console.log('Transaction hash:', txHash);

        if (!txHash) {
            throw new Error('No transaction hash received');
        }

        // –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        await this.waitForTransaction(txHash);

        console.log('Transaction confirmed');

        // –î–∞–µ–º –≤—Ä–µ–º—è –±–ª–æ–∫—á–µ–π–Ω—É –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        await new Promise(resolve => setTimeout(resolve, 1000));

        // –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –æ–± –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—á–µ—Ç–∞
        this.notifyScoreUpdate(playerAddress, score);
    }

    // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—á–µ—Ç–æ–≤
    public onScoreUpdate(callback: (player: string, score: number) => void): void {
        this.scoreUpdateCallbacks.push(callback);
    }

    // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –æ–± –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—á–µ—Ç–∞
    private notifyScoreUpdate(player: string, score: number): void {
        this.scoreUpdateCallbacks.forEach(callback => {
            try {
                callback(player, score);
            } catch (error) {
                console.error('Error in score update callback:', error);
            }
        });
    }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏
    private encodeCall(functionName: string, types: string[], values: string[]): string {
        // –°–æ–∑–¥–∞–µ–º —Å–∏–≥–Ω–∞—Ç—É—Ä—É —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –≤—ã—á–∏—Å–ª—è–µ–º –µ—ë Keccak-256 —Ö–µ—à
        const signature = `${functionName}(${types.join(',')})`;
        const hash = keccak256(signature);
        const methodId = '0x' + hash.slice(0, 8); // –ü–µ—Ä–≤—ã–µ 4 –±–∞–π—Ç–∞ (8 hex —Å–∏–º–≤–æ–ª–æ–≤)

        console.log(`Function: ${signature} -> Method ID: ${methodId}`);

        // –ö–æ–¥–∏—Ä—É–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã
        let encodedParams = '';
        let stringData = '';
        let currentOffset = types.length * 32; // –ö–∞–∂–¥—ã–π –±–∞–∑–æ–≤—ã–π —Ç–∏–ø –∑–∞–Ω–∏–º–∞–µ—Ç 32 –±–∞–π—Ç–∞

        for (let i = 0; i < values.length; i++) {
            const value = values[i];
            const type = types[i];

            if (type === 'address') {
                // –£–¥–∞–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å 0x –∏ –¥–æ–ø–æ–ª–Ω—è–µ–º –¥–æ 64 —Å–∏–º–≤–æ–ª–æ–≤
                const paddedValue = value.startsWith('0x') ? value.slice(2) : value;
                encodedParams += paddedValue.toLowerCase().padStart(64, '0');
            } else if (type === 'uint256') {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —á–∏—Å–ª–æ –≤ hex –∏ –¥–æ–ø–æ–ª–Ω—è–µ–º –¥–æ 64 —Å–∏–º–≤–æ–ª–æ–≤
                const hexValue = parseInt(value).toString(16);
                encodedParams += hexValue.padStart(64, '0');
            } else if (type === 'string') {
                // –î–ª—è —Å—Ç—Ä–æ–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º offset (—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ø–æ–∑–∏—Ü–∏—é —Å—Ç—Ä–æ–∫–∏)
                const offsetHex = currentOffset.toString(16).padStart(64, '0');
                encodedParams += offsetHex;

                // –ö–æ–¥–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É
                const stringBytes = new TextEncoder().encode(value);
                const lengthHex = stringBytes.length.toString(16).padStart(64, '0');
                const hexString = Array.from(stringBytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');

                // –î–æ–ø–æ–ª–Ω—è–µ–º —Å—Ç—Ä–æ–∫—É –¥–æ –∫—Ä–∞—Ç–Ω–æ–≥–æ 32 –±–∞–π—Ç–∞–º
                const paddedStringHex = hexString.padEnd(Math.ceil(hexString.length / 64) * 64, '0');

                stringData += lengthHex + paddedStringHex;
                currentOffset += 32 + Math.ceil(stringBytes.length / 32) * 32; // length + padded data
            }
        }

        // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –∫–æ–Ω–µ—Ü
        const result = methodId + encodedParams + stringData;
        console.log(`Encoded call: ${result}`);
        return result;
    }
}


